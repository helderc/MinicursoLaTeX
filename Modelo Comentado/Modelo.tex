\documentclass[11pt, a4paper]{article}

\usepackage[latin1]{inputenc} % pacote necessário para acentos do portugues
\usepackage[portuges]{babel} % linguagem em portugues para títulos e datas (\today)
\usepackage{amsmath, amssymb, gensymb} % toda a simbologia matemática
\usepackage{verbatim} % ambiente de códigos e/ou comandos
\usepackage{xcolor} % cor das letras
\usepackage{graphicx} % para inclusao de figuras
\usepackage[tight]{subfigure} % inclusão de varias figuras em um mesmo ambiente. Figuras lado-a-lado.
\usepackage{hyperref} % link entre as referências cruzadas.
\usepackage{array, ragged2e} % para o controle do alinhamento vertical da tabela

% arruma o problema de centralização vertical na segunda col. da tabela
\renewcommand*{\arraystretch}{1.6} 


\title{Atividades Laboratoriais}
\author{{\bf {\huge SECOMPP \& SMAT 2011}}}
\date{\today}

\begin{document}

\maketitle


\section{Algoritmo de Canny} \label{algoCanny}
Em 1986, John Canny definiu um conjunto de objetivos (três deles) que 
deveriam ser atingidos por um detector de arestas, descrevendo então um 
método ótimo:

\begin{description}
	\item[Taxa de Erro\textnormal{:}] O detector de arestas deve
	responder apenas as arestas e encontrar todas elas sem que nenhuma
	seja perdida;
	\item[Localização\textnormal{:}] A distância entre os {\it pixels} de uma
	aresta e o centro da mesma aresta encontrada por um detector deve
	ser tão pequena quanto possível;
	\item[Quantidade de Respostas]: O detector não
	identificaria múltiplos {\it pixels} na aresta onde apenas uma simples
	aresta existe. Em outras palavras, o número de máximos locais em
	torno da aresta verdadeira deve ser mínimo.
\end{description}

O algoritmo de Canny consiste em expressar matematicamente os três
critérios citados anteriormente, bem como encontrar soluções ótimas
para eles. Como é difícil encontrar algo que os satisfaçam completamente, 
o uso de otimizações com arestas de degrau unidimensionais
que foram corrompidas por ruído branco gaussiano, levam a conclusão 
de que, uma aproximação interessante, para este detector ótimo, 
é a primeira derivada de uma gaussiana, como mostra a Equação
\ref{cannyGaussianaDerivada}.

\begin{equation} \label{cannyGaussianaDerivada}
	G'(x) =\dfrac{d}{dx}e^{-\tfrac{x^2}{2\sigma^2}} = 
		-\frac{x}{\sigma^2}e^{-\tfrac{x^2}{2\sigma^2}}
\end{equation}

Supondo que $f(x,y)$ seja a imagem a ser processada e, temos então a função 
$G(x,y)$, ilustrada na Equação \ref{cannyGaussiana2D}.

\begin{equation} \label{cannyGaussiana2D}
	G(x,y) = e^{-\tfrac{x^2 + y^2}{2\sigma^2}}
\end{equation}

Agora fazendo a convolução da imagem $f$ com a função gaussiana $G$ 
temos:

\begin{equation} \label{cannyConvolucao2D}
	f_s{(x,y)} = G(x,y) \times f(x,y)
\end{equation}

Logo após calculamos a magnitude e a direção (ângulo) do vetor 
gradiente:

\begin{eqnarray}
	M(x,y) = \sqrt{g^2_x + g^2_y} \\ [0.8em]
	\alpha(x,y) = tg^{-1}\left[ \dfrac{g_y}{g_x} \right] \label{cannyVetorNormal}
\end{eqnarray}

\noindent onde:

\begin{eqnarray}
	g_x = \dfrac{\partial f_s}{\partial x} & 
	\text{ e } & 
	g_y = \dfrac{\partial f_s}{\partial y}
\end{eqnarray}

Assumindo que $d_1$, $d_2$, $d_3$ e $d_4$ indicam as quatro direções
(horizontal, $-45\degree$, vertical e $+45\degree$) possíveis para uma
aresta $3 \times 3$. O esquema de supressão para esse caso consiste em:

\begin{itemize}
	\item Encontrar a direção $d_k$ que está mais próxima de 			
	$\alpha(x,y)$;
	\item Se $M(x,y)$ é menor a pelo menos um dos {\it pixels} de sua 	
	vizinhança ($d_k$), então $g_n(x,y)=0$ ocasionando uma supressão,
	caso contrário $g_n(x,y)=M(x,y)$.
\end{itemize}

O $g_n(x,y)$ citado anteriormente é a imagem com a supressão de não
máximos ou seja, $g_n(x,y)$ é a imagem com as bordas afinadas.

A operação de limiarização de Canny pode ser visualizada utilizando
a criação de duas outras imagens:

\begin{equation}
    g_{nH}(x,y) = g_n(x,y) \leqslant T_H
\end{equation}

\noindent e

\begin{equation}
	g_{nL}(x,y) = g_n(x,y) \leqslant T_L
\end{equation}

\noindent onde no começo tanto $g_{nH}$ quanto $g_{nL}$ irá ter apenas
valores 0 e, após a limiarização, $g_{nH}$ terá uma quantidade de 
{\it pixels} zero menor do que $g_{nL}$, porém, todos os {\it pixels} que forem 
diferentes de zero em $g_{nH}$ serão adicionados a imagem $g_{nL}$
porque a última imagem será formada com um limiar mais baixo ainda:

\begin{equation}
	g_{nL}(x,y) = g_{nL}(x,y) - g_{nH}(x,y)
\end{equation}

Depois de feitas as operações de limiarização, os {\it pixels} poderão ser
classificados como fortes e fracos. Todos os {\it pixels} fortes de 
$g_{nH}(x,y)$ são marcados como {\it pixels} verdadeiros da aresta. 


\begin{equation}
	M(x,y) = \sqrt{I_x'(x,y)^2 + I_y'(x,y)^2}
\end{equation}


O resultado da aplicação do algoritmo de Canny que discutimos ao longo desta
seção, fizemos o teste na Figura \ref{fig:lena2} e, como imagem resultante
obtivemos a Figura \ref{fig:cannySigma1}. Esta imagem também
foi processada pelo sistema desenvolvido. Para os testes, utilizamos os 
parâmetros: $\sigma = 1$,  limiar inferior  $= 0$ e  limiar superior $= -1$.

\begin{figure}[!h]
    \centering
	\subfigure[Imagem original.]{
            \includegraphics[scale=0.30]{lena.jpg}
            \label{fig:lena2}
        }
    \subfigure[$\sigma = 1$; limiar inferior $= 0$; limiar superior $= -1$ ]{
            \includegraphics[scale=0.4]{canny_sig1_threL0_threHmenos1.png}
            \label{fig:cannySigma1}
        }
    \caption{Resultado obtido com o algoritmo de Canny.}
    \label{fig:cannyResultado}
\end{figure}




\section{Transformadas de Fourier}
A Transformada de Fourier, baptizada em homenagem a Jean-Baptiste Joseph Fourier, 
é uma transformada integral que expressa uma função em termos de funções de base 
sinusoidal, i.e., como soma ou integral de funções sinusoidais multiplicadas por 
coeficientes (``amplitudes''). Existem diversas variações directamente relacionadas 
desta transformada, dependendo do tipo de função a transformar.


\subsection{Transformada contínua de Fourier}
Geralmente, a denominação ``Transformada de Fourier'' refere-se à Transformada 
de Fourier para funções contínuas, que representa qualquer função integrável $f(t)$ 
como a soma de exponenciais complexas com frequência angular $\omega$ e amplitude 
complexa $F(\omega)$:

\[
	F(\omega) = \int_{-\infty}^{\infty}{f(t)e^{-i\omega t}dt}  
\]

\[
	f(t) = F^{-1}(F(\omega)) = \frac{1}{2\pi} \int_{-\infty}^{\infty}{F(\omega)e^{i\omega t} d\omega} 
\]



\subsection{Transformada discreta de Fourier}
Para uso em computadores, seja para aplicações científicas ou em 
processamento digital de sinais, é preciso ter valores $x_k$ discretos. 
Para isso existe a versão da transformada para funções discretas.

\[
	x_k = \frac{1}{n} \sum_{j=0}^{n-1}{f_je^{\frac{2\pi i}{n}jk}} \qquad k = 0, \dots, n-1.
\]

\[
	f_j = \sum_{k=0}^{n-1}{x_ke^{\frac{2\pi i}{n}jk}} \qquad j = 0, \dots, n-1.
\]




\subsection{Algumas transformadas de Fourier}
Nesta tabela, $\delta (t)$ é a delta de Dirac, e $u(t)$ é a função de passo Heaviside,
$sgn$ é a função sinal, rect é a função retangular, $sinc$ é a função 
$sinc(x) = \frac{sen (\pi x)}{\pi x}$.

\begin{table}[!h]
	\centering
	\begin{tabular}{| m{3cm} | m{5cm}|}
	\hline $\mathbf{f(t)}$ & $\mathbf{F(\omega)}$ \\ 
	\hline $\delta (t)$ &  1 \\
	\hline $\delta (t-a)$ & $e^{-ia\omega}$ \\ 
	\hline $u(t)$ & $\pi \delta (\omega) + \frac{1}{i\omega}$ \\ 
	\hline 1 & $2\pi \delta (\omega)$ \\ 
	\hline $sgn(t)$ & $\frac{2}{i\omega}$ \\
	\hline $rect(t/a)cos(\omega_0 t)$ & $a \left( sinc\frac{(\omega - \omega_0)a}{2\pi} + sinc\frac{(\omega + \omega_0)a}{2\pi} \right)$ \\ 
	\hline 
	\end{tabular} 
	\caption{Fonte: \url{http://pt.wikipedia.org/wiki/Transformada_de_Fourier}}
\end{table}



\end{document}
